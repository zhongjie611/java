# 享学课堂VIP课程大纲

## 开源框架解析专题

### Spring5

#### IOC容器及源码解读

##### 容器启动及配置类加载流程

###### 加载配置类

###### 包路径扫描

##### 组件添加

###### @ComponentScan自动描述组件

###### @Bean

####### Bean的创建、初始化、销毁

####### Bean的后置处理BeanPostProcessor

###### @Configuration配置注解详解

###### @Controller、@Component、@Service、@Repository注解组件详解 

###### @Conditional、@Primary、@Lazy、@Scope、@Import注解详解

###### ImportSelector选择器

###### FactoryBean

####### 工厂模式

##### 组件赋值

###### @Value属性赋值及@PropertySource、@PropertySources注解详解

###### @Autowired、@Resources、@Inject区别与联系

###### @Qualifier

##### 组件注入

###### 构造函数注入

###### 方法参数注入

###### Aware接口说明

##### 后置处理器

###### BeanFactoryPostProcessor

###### BeanDefinetionRegistry

##### 声明式事务源码解读

###### 事务管理功能开启

###### 事务操作实战

###### 事务源码分析实战

##### Spring5容器源码解读

###### BeanFactory初始化

###### BeanFactory后置处理器执行

###### 各类BeanPostProcessors注册执行

###### MessageSource资源国际化初始化

###### 事件派发器、监听器初始化

###### Bean准备创建工作

###### Bean完成创建

###### 完成容器创建

#### AOP使用与源码分析

##### @EnableAspectJAutoProxy注解

##### 切面注解使用解析

##### AOP源码解读实战

###### AOP核心类的注册及执行时机分析

###### AOP代理创建原理及源码剖析

###### AOP核心功能之拦截器链-MethodInterceptor解析

###### 方法压栈及链式调用原则解析

###### AOP总结与回顾

### SpringMVC

#### Servlet3.0的注解实现

##### ServletContainerInitializer容器初始化

##### ServletRegistration注册

##### FilterRegistration过滤器

##### ServletContext

#### 性能实战

##### 基于Servlet3.0异步

##### Callable异步

##### DeferredResult异步

#### 手写SpringMVC实战

### Mybatis

#### 概述

##### 为什么要用ORM

##### 为什么使用MyBatis

##### MyBatis快速入门

#### 进阶

##### MyBatis的配置

##### 映射器的配置

###### 基于XML

###### 基于注解

##### 动态SQL

##### 与Spring的集成

###### 集成的配置

###### 集成的原理分析

##### 缓存

##### 关联查询

##### 代码生成器

#### 高级

##### 源码分析

##### 插件开发

##### 分页插件使用与源码分析

#### 实战

##### 快速入门

##### 与Spring的集成

##### 多对多级联

##### 源码分析作业

##### 手写一个MyBatis框架

## 团队协作开发专题

### Git

#### Git基本工作原理

##### 与SVN对比

##### 基本运作流程

#### Git常用操作及问题处理

##### 工程初始化及克隆

##### 文件提交

##### 分支与常用标签应用

##### 远程仓库管理

##### 合并与冲突解决

##### 架构师职责：Git Flow必备技能，规范团队Git操作

##### 架构师曾踩过的坑经验分享

### Maven

#### 安装和配置

##### Windows上安装

##### Liunx上安装

##### 目录分析

#### 使用入门

##### 编写POM

##### 编写主代码

##### 编写测试代码

##### 打包和运行

#### 坐标和依赖

##### Maven坐标以及详解

##### 依赖的配置

##### 依赖的范围

##### 传递性依赖和依赖调解

#### 聚合与继承

##### 聚合

##### 继承

##### 聚合与继承的关系

##### 约定优于配置

##### 反应堆

#### 生命周期与插件

##### clean生命周期

##### default生命周期

##### site生命周期

##### 命令行与生命周期

##### 插件目标

##### 插件绑定

##### 插件配置

##### 常用插件

#### 仓库

##### 本地仓库

##### 远程仓库

##### 中央仓库

##### 快照版本

##### 远程仓库的配置

##### 快照版本与镜像

#### 版本管理

##### 版本号定义约定

##### 主干、标签与分支

#### 私服－Nexus

##### 安装Nexus

##### Nexus的仓库与仓库组

##### Nexus使用、上传、配置

#### Maven实战与手写自己的插件

### Jenkins

#### 环境搭建

##### Jekins安装

##### Jenkins Tomcat安装

##### Jenkins Git安装

##### Jenkins Maven安装

#### 配置管理

##### Jenkins配置

##### Jenkins管理

##### Jenkins配置程序作业

##### Jenkins配置单元测试

##### Jenkins配置自动化测试

#### 部署分析

##### Jenkins配置邮件通知

##### Jenkins配置报表

##### Jenkins代码分析

##### Jenkins分布式构建

##### Jenkins自动部署

#### 高级进阶

##### Jenkins指标与趋势

##### Jenkins服务器维护

##### Jenkins持续部署

##### Jenkins插件管理

##### Jenkins备份

##### Jenkins远程测试

## 高性能架构专题

### 分布式架构思维

#### 大型互联网架构演进过程

#### 架构师应具备的分布式知识

#### 主流分布式架构设计详解

### 分布式协调和分流

#### Zookeeper分布式环境指挥官

##### zk的入门

###### 会话

###### 节点属性

###### 节点类型

###### 版本

###### 监听器机制

###### 安全权限

###### 单机部署

###### zk的命令

##### zk开发基础

###### 原生客户端

###### zkclient

###### curotor

##### zookeeper应用实战

###### 配置中心

###### 分布式锁

###### 集群选举

###### 命名服务

##### 协议

###### 2p,3p

###### cap

###### base

###### paxos 

###### zab

#### Nginx高并发分流进阶实战

##### nginx安装

###### 常用服务器介绍

###### nginx安装及常见问题

###### 目录结构

###### 常用命令

##### 正反向代理

###### 什么是正向代理

###### 什么是反向代理

##### nginx进程模型

###### 模型及基本概念

###### 发送信号方式

##### 核心配置结构

###### conf配置文件结构

###### main全局配置

###### http服务器

###### server虚拟主机

###### 访问控制 allow/deny

###### location

##### 日志配置及切割

###### Nginx日志格式

###### Nginx日志分隔

###### crontab设置作业

##### location规则

###### 匹配优先级

###### Location规则

###### Location解析过程

###### if指令

###### return指令

###### 内置变量

##### rewrite的使用

###### URL重写场景

###### rewrite语法格式

###### regex 常用正则表达式

###### rewrite过程

##### 动静分离实战

###### mvvm模式的交互

###### 动静分离的两种方式

###### 伪静态

###### 动静分离实例

##### 反向代理实战

###### 反向代理的场景

###### 基础用法

###### 负载均衡

###### 4种负载方式

##### 跨域配置实战

###### 跨域的由来

###### 跨域的解决方案

###### cors方案用法

###### 简单请求与复杂请求

##### 缓存配置及Gzip配置实战

###### 静态资源缓存配置

###### 资源压缩配置

##### https配置实战

###### 信息传输安全概念

###### HTTPS简介

###### openssl生成证书

###### Nginx.conf配置证书

##### 横向拓展带来的问题

##### LVS实战

###### Nginx高可用概述

###### Keepalived原理

###### 配置抢占式模式

### 异步与消息中间件

#### 概述

##### 什么是消息中间件？和RPC有何区别？

##### 消息中间件使用场景介绍

##### 消息中间件(ActiveMQ、RabbitMQ、RocketMQ、Kafka)简介及对比

##### 消息中间件的编年史

#### ActiveMq消息中间件

##### JMS规范

###### 什么是JMS（Java Messaging Service）规范？

###### 包含要素

###### 消息类型

###### P2P模型

###### Topic(PUB\SUB)模型

##### ActiveMQ使用

###### 安装和部署

###### 原生ActiveMQ的API编程

###### 与Spring集成

####### Xml配置方式

####### SpringBoot

###### Request-Response模式

###### 实战：用户注册的异步处理

##### ActiveMQ高级特性和用法

###### 嵌入式MQ

###### 消息存储的持久化机制

###### 消息持久订阅

###### 消息的可靠性

###### 通配符式分层订阅

###### 死信队列DLQ(Dead Letter Queue)

###### 镜像队列

###### 虚拟主题

###### 组合Destinations

##### 实战：限时订单

##### 企业级高可用集群部署方案

###### Shared

####### File System 

####### DB

###### Replicated LevelDB Store

###### Broker-Cluster

#### RabbitMq消息中间件

##### AMQP规范和RabbitMQ基本概念

###### 要素

####### 生产者、消费者、消息

####### 信道

####### 交换器、队列、绑定、路由键

###### 消息的确认

###### 交换器类型

####### Direct

####### Fanout

####### Topic

###### 虚拟主机

##### Windows下安装和运行

##### Linux下安装与配置

###### 下载安装和日常管理

###### web监控平台

##### 原生Java客户端使用

##### 消息发布时的权衡

###### 失败通知

###### 发布者确认

###### 事务

###### 备用交换器

##### 消息消费时的权衡

###### 消息的获得方式

###### QoS预取模式

###### 可靠性和性能的权衡

##### 消息的拒绝

###### 消息的拒绝方式

###### 死信交换器

##### 控制队列

###### 临时队列

###### 永久队列

###### 队列级别消息过期

##### 消息的属性

###### 属性列表

###### 消息的持久化

##### 与Spring集成

###### Xml配置方式

###### SpringBoot

###### 实战：应用解耦

##### 集群化与镜像队列

#### Kafka百万级吞吐实战

##### Kafka入门

###### Kafka中的基本概念

####### 消息和批次

####### 主题和分区

####### 生产者和消费者、偏移量、消费者群组

####### Broker和集群

###### 为什么选择Kafka

####### 多生产者和多消费者

####### 基于磁盘的数据存储

####### 高伸缩性

####### 高性能

####### 常见场景

##### Kafka的安装和配置参数

###### 安装

###### 运行

###### 基本的操作和管理

###### Broker配置

###### 硬件配置对Kafka性能的影响

##### Kafka的集群

###### 为何需要Kafka集群

###### 如何估算Kafka集群中Broker的数量

###### Broker如何加入Kafka集群

##### Kafka的生产者和消费者

###### 消息的发送和接收

###### 生产者和消费者的配置

###### 生产者发送消息的基本流程

###### Kafka生产者高级特性

####### 三种发送方式

####### 多线程下的生产者

####### 更多发送配置

####### 顺序保证  

####### 序列化

####### 分区

###### Kafka消费者高级特性

####### 消费者群组

####### 分区再均衡

####### 订阅

####### 轮询

####### 多线程下的消费者

####### 消费者配置  

####### 提交和偏移量

####### 再均衡监听器

####### 独立消费者

##### 整合Spring

###### Spring和Kafka的整合

###### SpringBoot和Kafka的整合

##### 深入理解Kafka

###### 控制器

###### 复制-Kafka的核心

###### 集群的成员关系

###### 处理请求的内部机制

###### 物理存储原理

##### 保证Kafka的可靠数据传递

###### Kafka提供的可靠性保证和架构上的权衡

###### Broker配置对可靠性的影响

####### 复制系数

####### 不完全的首领选举

####### 最少同步副本

##### 大数据初窥门径

###### 数据管道基本概念

###### 流式处理基本概念

###### 流式处理小实战

##### 削峰填谷实战

### 缓存和NoSQL

#### Redis高性能缓存数据库

##### Redis初入门及介绍

###### 基本介绍

###### 简单安装

###### 启动、运行、停止

##### Java客户端

###### Jedis

###### Jedispool

###### 手写Jedis实战

##### Redis常用命令及应用场景

###### set、get、lpush、lrange、hmget、hmset、pipeline

###### String、List、Hash、Set、Zset类型使用场景

###### 时间轴、队列应用场景设计

###### 购物车开发与设计实战

###### Redis与Lua模拟抢红包实战

###### 网站投票设计与开发实战

##### 数据一致性

###### Lua语言结合开发

###### 弱事务体现

###### multi、watch、discard、exec

##### Redis性能优化

###### BenchMark

###### Slowlog-more-than

###### slowlog-len

##### Redis主从模式

###### 一主一从

###### 一主多从、树型主从

##### Redis持久化

###### RDB

###### AOF

###### 数据恢复与转移实战

##### 哨兵核心机制

###### 选举原理

###### 主观下线

###### 客观下线

###### Java与哨兵如何工作

###### 动手搭建Spring与Redis哨兵模式集成实战

##### 高可用集群

###### 槽的介绍

###### 键槽关系

###### 分布式存储

###### 重定向

###### 手把手搭建Redis高可用集群

###### JedisCluster

###### JedisCluster+SpringMVC整合

###### 动态扩容、缩减集群节点实战

#### MongoDB进阶

##### mongodb入门

###### nosql与sql使用场景分析

###### 基础概念

####### 数据库

####### 集合

####### 索引

####### 文档

##### mongodb进阶

###### 常用命令

###### 快速入门

###### mongodb客户端驱动

###### 增删改查与聚合

###### 安全控制

##### mongodb高级知识

###### 存储引擎

###### 索引

####### 索引分析

####### 查询优化

####### 索引的注意事项

###### 高可用

####### 复制架构解析

####### 分区实战

##### 最佳实践与注意事项

#### 缓存解决方案实战

##### 缓存的概念

###### 频率高/变化少

###### 命中率

###### 绝对过期

###### 滑动过期

###### 实战编码说法

##### springcache的用法

###### 编程式用法

###### cache管理器的配置

###### cache标签的用法

###### 标签解析：key生成机制

###### 标签解析：带条件缓存

###### 标签解析：spel表达式

##### 缓存的一致性策略

###### 缓存导致的不一致问题

###### 实时更新策略

###### 准实时更新策略

###### 失效机制策略

###### 定时任务更新策略

##### 缓存雪崩方案

###### 什么是缓存雪崩

###### 雪崩的预防

###### 雪崩后限流

##### 缓存穿透方案

###### 击穿的概念

###### 缓存空数据

###### 布隆过滤器

### 高可靠数据存储

#### Mysql高性能存储实战

##### Mysql

###### Mysql主从复制、读写分离高可用方案实战

###### Mysql+Keepalived实现双主高可用方案实战

###### Mysql实现分库分表高性能解决方案实战

##### Mycat

###### Mycat简介及用途

###### 基于Mycat实现Mysql读写分离实战

###### 基于Mycat实现数据库切分实战

###### 全局表、ER表、分片机制分析

#### FastDFS分布式文件存储实战

##### 文件存储实战

##### 文件同步实战

##### 文件查询实战

##### 分布式部署实战

### 分布式常见场景解决方案实战

#### 事务概念

##### 事务与锁

##### 分布式事务产生背景

##### X/OpenDTP事务模型

##### 标准分布式事务

#### 分布式事务解决方案

##### 两阶段提交

##### BASE理论与柔性事务

##### TCC方案

##### 补偿性方案

##### 异步确保型与最大努力型

#### 单点登陆方案

##### 单点登陆的问题背景

##### 页面跨域问题

##### Session跨域共享方案

##### session的扩展

#### 分布式任务调度方案

##### Quartz调度的用法

##### Elastic-Job示例

##### 分布式调度的疑难点

##### Quartz集群定制化分布式调度

## 微服务架构专题

### RPC原理

#### RMI的实现

#### 原理

##### 服务注册与发布

##### 动态代理

##### 序列化与反射

#### 手写RPC框架

### Dubbo应用及源码解读

#### dubbo简介

##### 分布式中rpc调用的痛点

##### dubbo主要解决哪些rpc问题

##### dubbo涉及的概念

##### dubbo的部署安装

#### dubbo的配置使用

##### xml方式

##### 注解方式

##### api方式

##### dubbo中各元素属性学习

#### dubbo在项目的用法

##### 类与类的依赖关系说明

##### 项目之间的依赖划分

##### 实战拆解分布式

#### dubbo源码解析与示例

##### dubbo的模块及层级

##### dubbo的初始化过程

##### dubbo的服务暴露

##### dubbo的服务引用

##### dubbo的服务拦截

##### 服务的注册与发现

### SpringBoot底层探析

#### SpringBoot快速入门

##### SpringBoot与微服务之间的关系

##### 环境搭建

##### 集成springmvc

##### 集成mybatis

##### 整合日志

##### 集成jsp

##### 全局异常捕获

##### 打包部署

##### 热部署

##### 集成Swagger2构建API管理体系

#### 进阶

##### 核心组件

###### starter

###### actuator

###### auto-configuration

###### cli

##### 性能优化

###### jvm参数

###### 扫包优化

###### undertow容器

##### jta+atomikos分布式事务

#### SpringBoot核心原理实战

##### @SpringBootApplication源码解读

##### 纯手写打造SpringBoot雏形

###### 框架整合业务逻辑层

###### 整合jsp视图

###### 内置集成tomcat

### SpringCloud高级进阶

#### Zuul路由网关详解及源码探析

#### Ribbon客户端负载均衡原理与算法详解，与服务端负载均衡区别

#### Feign声明式服务调用方式实现

#### Hystrix服务熔断及服务降级实战

#### Eureka注册中心构件分析

#### Config配置服务中心与svn、git快速集成

#### BUS消息总线技术

#### Sleuth调用链路跟踪

#### Stream 消息驱动的微服务

### Docker虚拟化技术

#### Docker介绍、安装与使用

#### Docker组成

##### 镜像

##### 容器

##### 私有仓库

#### Docker Compose部署脚本

#### Docker Service 服务编排

#### Docker Redis分布式集群部署

#### Docker File构建

#### 通过Maven插件打包Docker镜像

#### Docker部署及运行应用程序

#### Kubernetes编配

#### 基于Docker构建Mysql集群实战

#### 高可用SpringCloud微服务与Docker集成实现动态扩容实战

## B2C商城项目实战

### 系统设计

#### 架构设计

#### 数据库设计

#### 部署设计

#### 基础开发框架讲解

### 用户管理子系统

#### 用户注册 登录（二维码技术）

#### 权限控制（shiro）

#### 单点登录（session统一缓存、sso）

### 商品管理子系统

#### 商品管理（mongodb）

#### 商品分类（mongodb）

#### 商品发布（nosql与mysql数据同步）

#### 热卖商品排行（redis）

### 搜索子系统

#### 基于ElasticSearch搜索引擎的全文检索

#### 检索需求分析

#### 检索策略

#### 索引设置

#### 分词算法

#### 命中率优化

#### 订单实时统计

### 订单子系统

#### 分布式环境生成唯一编号（ZooKeeper）

#### 下单业务流程（消息中间件）

#### 订单可靠性

#### 秒杀功能（Redis）

#### 订单管理

#### 购物车功能（MongoDB）

### 支付系统

#### 微信支付对接

#### 支付宝对接

#### 银联对接开发

### 分布式调度系统 

#### 数据统计

#### 数据同步

#### 任务调度配置

### 后台系统

#### 日常管理

#### 在线IM系统 （WebSocket NIO）

#### 用户行为分析

#### 报表大数据查询优化

## 架构师筑基专题

### 扎实Java基础

#### 并发编程进阶

##### 1、线程基础、线程

###### 之间的共享和协作

####### 基础概念

######## CPU核心数，线程数

######## CPU时间片轮转机制

######## 什么是进程和线程

######## 什么是并行和并发

######## 高并发编程的意义、好处和注意事项

####### 启动和终止线程

######## 三种启动线程的方式

######## 理解中断

######## 如何安全的终止线程

####### 线程再认识

######## 线程常用方法

######## 线程的状态

######## 线程的优先级

######## Demon线程

####### 线程间的共享

######## synchronized

######### 对象锁

######### 类锁

######## volatile

######## ThreadLocal

####### 线程间协作

######## Wait,Notify/NotifyAll

######## 等待和通知的标准范式

######## notify和notifyAll应该用谁

######## Join方法

######## 调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？

##### 2、线程的并发工具类

###### Fork/Join

####### 什么是分而治之？

####### 工作密取

####### 使用的标准范式

###### CountDownLatch作用、应用场景和实战

###### CyclicBarrier作用、应用场景和实战

###### CountDownLatch和CyclicBarrier辨析

###### Semaphore作用、应用场景和实战

###### Exchange作用、应用场景和实战

###### Callable、Future和FutureTask

##### 3、原子操作CAS

###### CAS的原理

###### CAS的问题

####### ABA问题

####### 开销

####### 只能保证一个共享变量的原子操作

###### 原子操作类的使用

####### 基本类型

####### 数组

####### 引用

####### 带版本戳

##### 4、显式锁和AQS

###### 显式锁

####### Lock接口、核心方法和使用

####### Lock接口和synchronized的比较

####### ReentrantLock可重入锁与锁的公平和非公平

####### ReentrantReadWriteLock使用场景

####### Condition用法

###### LockSupport工具进阶

###### AbstractQueuedSynchronizer实现及源码分析

####### 什么是AQS？学习它的必要

####### AQS使用方式和其中的设计模式

####### 了解其中的方法

####### 实现一个自己的独占锁 

####### AQS中的数据结构

####### 节点在同步队列中的增加和移出

####### 独占式同步状态获取与释放

####### 共享式同步状态获取与释放

####### Condition分析

######## 等待队列

######## await方法

######## signal方法

####### 深入源码

####### 了解ReentrantLock的实现

######## 锁的可重入

######## 公平和非公平锁

####### 了解ReentrantReadWriteLock的实现

##### 5、并发容器

###### ConcurrentHashMap

####### 使用

####### 实现

######## 基本思想

######## 预备知识

######### Hash

######### 位运算

######## jdk1.7

######### 构造方法

######### 如何定位

######### get方法

######### put方法

######### 扩容

######## jdk1.8

######### 构造方法

######### 如何定位

######### get方法

######### put方法

######### 扩容

###### 其他并发容器

####### ConcurrentSkipListMap等

######## 了解什么是SkipList

####### ConcurrentLinkedQueue  

####### 写时复制容器

###### 阻塞队列

####### 概念

####### 生产者消费者模式

####### 常用方法

####### 常用阻塞队列辨析

######## ·ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。

###### ·LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。

###### ·PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。

###### ·DelayQueue：一个使用优先级队列实现的无界阻塞队列。

###### ·SynchronousQueue：一个不存储元素的阻塞队列。

###### ·LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。

###### ·LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

####### 延时队列实战

####### 阻塞队列实现原理

##### 6、线程池

###### 什么是线程池？为什么要用线程池？

###### 实现一个我们自己的线程池

###### JDK中的线程池

####### 线程池的创建

####### 提交任务

####### 关闭线程池

###### 线程池工作机制

###### 合理配置线程池

###### 系统为我们预定义的线程池

####### FixedThreadPool
SingleThreadExecutor
CachedThreadPool
WorkStealingPool

######## 含义

######## 使用场景

####### ScheduledThreadPoolExecutor

######## 含义

######## 使用场景

######## 内部方法辨析

###### Executor框架

###### CompletionService

####### 使用

####### 优点

##### 7、并发安全

###### 类的线程安全

###### 如何做到类的线程安全

####### 无状态

####### 让类不可变

####### 更多......

###### 线程不安全引发的问题

####### 死锁

######## 原因

######## 表现

######## 检测和解决

####### 活锁

####### 多线程程序

####### 性能和思考

######## 影响性能的因素

######## 减少锁的竞争

###### 线程安全的单例模式

####### 如何让双重检查锁定安全

####### 懒汉式

####### 饿汉式

##### 8、实战项目

###### 并发任务执行框架

####### 需求的产生和分析 

####### 需要做什么

######## 封装多线程，屏蔽细节

######## 保存任务的上下文

######## 自动清除已完成和过期任务

####### 具体实现

######## 可查询进度的并发任务执行框架

###### 应用性能优化实战

####### 项目简介

####### 项目分析，为何优化

####### 分析和改进

######## 架构改进

######## 单服务改进

####### 如何继续改进

####### 带来的启示

##### 9、JMM和底层实现原理

###### 现代计算机物理

###### 上的内存模型

####### 概念

####### 带来的问题

###### Java内存模型

###### （JMM）

####### JVM对Java内存

###### 模型的实现

####### 带来的问题

####### 重排序

######## 类型

######## 依赖性

######## as-if-serial

######## 重排序带来的问题

######## 内存屏障

######## 临界区

####### Happens-Before

######## 定义

######## 规则

####### volatile的内存语义

######## 概念和深入理解

######## 内存语义的实现

######### 重排序规则

######### 内存屏障插入策略

####### 锁的内存语义

####### final的内存语义

####### volatile的实现原理

####### synchronized的实现原理

#### JVM性能调优

##### 1、Java内存区域

###### 虚拟机的历史

###### 未来的Java技术一览

###### 运行时数据区域

####### 程序计数器

####### 栈

####### 堆

####### 方法区

####### 运行时常量池

####### 各个版本内存区域的变化

######## 1.6

######## 1.7

######## 1.8

####### 直接内存

###### 站在线程角度来看堆和栈

###### 深入辨析堆和栈

###### 方法的出入栈

####### 栈桢

####### 栈上分配

###### 虚拟机中的对象

####### 分配过程

####### 内存布局

####### 对象的访问定位

###### 堆参数设置和内存溢出实战

####### Java堆溢出

####### 新生代配置

####### 方法区和运行时常量池溢出

####### 虚拟机栈和本地方法栈溢出

####### 本机直接内存溢出

##### 2、垃圾回收器和内存分配策略

###### GC概述

###### 判断对象的存活

###### 辨析强、弱等各种引用

###### GC算法

####### 标记-清除算法

####### 复制算法

####### 标记-整理算法

###### 分代收集

###### 垃圾回收器

####### 垃圾回收器概览

####### 垃圾回收器工作详解

####### G1详解

####### 未来的垃圾回收

###### Stop The World现象

###### GC日志解读

###### 内存分配与回收策略

###### 内存泄漏和内存溢出辨析

###### JDK为我们提供的工具

###### 了解MAT

##### 3、JVM的执行子系统

###### Class类文件本质

###### Class文件格式

###### 字节码指令

###### 类加载机制

####### 加载过程详解

####### 类加载器

######## 自定义类加载对类进行加密和解密

######## 系统的类加载器

######## 双亲委派模型

####### Tomcat类加载机制

###### 栈桢详解

###### 方法调用详解

###### 基于栈的字节码解释执行引擎

####### 基于栈的指令集与基于寄存器的指令集

####### 分析代码在虚拟机中的执行情况

##### 4、编写高效优雅Java程序

###### 构造器参数太多怎么办？

###### 不需要实例化的类应该构造器私有

###### 不要创建不必要的对象

###### 避免使用终结方法

###### 使类和成员的可访问性最小化

###### 使可变性最小化

###### 优先使用复合

###### 接口优于抽象类

###### 可变参数要谨慎使用

###### 返回零长度的数组或集合，不要返回null

###### 优先使用标准的异常

###### 用枚举代替int常量

###### 将局部变量的作用域最小化

###### 精确计算，避免使用float和double

###### 当心字符串连接的性能

##### 5、深入了解性能优化

###### 常用的性能评价/测试指标

####### 响应时间

####### 并发数

####### 吞吐量

####### 相互之间的关系

###### 常用的性能优化手段

####### 总原则

####### 前端优化手段

####### 应用服务性能优化

####### 存储性能优化

###### 详细了解应用服务性能优化

####### 缓存

######## 缓存的基本原理和本质

######## 合理使用缓冲的准则

######## 分布式缓存与一致性哈希

####### 集群

####### 异步

######## 同步和异步，阻塞和非阻塞

######## 常见异步的手段

####### 应用相关

######## 代码级别

######## 并发编程

######## 资源的复用

######## JVM

######### 与JIT编译器相关的优化

######### GC调优

######### JVM调优实战

#### 网络编程与高效IO

##### 网络协议

###### 网络模型

####### OSI七层模型

####### TCP/IP模型

###### TCP

####### 三次握手

####### 四次挥手

####### 缓冲区/滑动窗口

###### UDP

####### DatagramSocket

####### DatagramPacket

###### HTTP

####### HTTP 协议报文结构

####### 一次完整http请求的7个过程

####### HTTP请求的传输过程

###### 原生JDK网络编程

####### BIO编程

######## ServerSocket

######## Socket

####### NIO编程

######## Reactor模式

######## NIO重要概念

######## Buffer辨析

##### 1、Netty应用

###### Netty是什么？为什么要用Netty？

###### 第一个Netty程序

####### Netty核心组件初步了解

####### Hello，Netty

###### Netty组件再了解

####### Channel、EventLoop 和ChannelFuture

####### ChannelHandler 和ChannelPipeline

####### 内置通信传输模式

####### ByteBuf

###### 解决粘包，半包问题

###### 编解码器框架

####### 实现基于Netty的Web服务器

###### 序列化问题

###### 单元测试

##### 2、Netty进阶和实战

###### 实现UDP通信

####### 实现UDP通信

######## 单播

######## 广播

###### 服务器推送技术

####### 短轮询

####### Comet

######## Servlet异步任务

######## 服务器推模型SSE

###### WebSocket通信

####### 概念和原理

####### 微信风格基于

####### STOMP的SpringBoot

######## 群聊

######## 一对一聊天

####### SpringBoot和WebSocket的集成

####### 基于Netty

###### 实现自己的通信框架

####### 基于Netty的NIO通信框架

####### 提供高性能的异步通信能力

####### 实现POJO的序列化和反序列化

####### 基于IP地址的白名单接入认证机制

####### 链路的有效性校验机制

####### 链路的断连重连机制

##### 3、Netty源码分析

###### 引导过程分析

###### EventLoop和EventLoopGroup分析

###### 服务端接收连接事件分析OP_ACCEPT

###### 分析读事件OP_READ

###### 分析写数据和处理写事件OP_WRITE

###### 分析客户端连接和连接事件OP_CONNECT

### Tomcat系统进阶

#### 1，目录结构

##### 配置文件

###### server.xml

###### web.xml

###### context.xml

###### catalina.policy

##### lib

###### tomcat-xxx.jar

###### servlet.jar

##### logs

###### localhost-xxx.log

###### catalina-xxx.log

##### webapps

###### 显式部署

####### 添加context元素

####### 创建xml文件

###### 隐式部署

#### 2，容器

##### Engine

##### Pipeline

##### AccessLog

##### Realm

#### 3，Jasper解析器

#### 4，Connector连接器

##### Endpoint

##### Processor

##### CoyoteAdapter

##### Mapper

#### 5，线程模型

##### 阻塞式(BIO)

##### 非阻塞式(NIO)

#### 6，源码解读

##### 源码环境搭建

##### 源码架构分析

##### 核心组件分析

##### 源码调试

###### 调试启动流程

###### 调试生命周期的管理

#### 7，嵌入式Tomcat

##### Tomcat的API

##### Tomcat的Maven插件

##### 手写嵌入式Tomcat

#### 8，Tomcat优化实战

### Mysql深度优化

#### 1，Mysql逻辑架构入门介绍

#### 2，存储引擎

##### MyISAM

##### Innodb

##### Archive

##### Memory

##### Federated

#### 3，业务设计

##### 锁

###### 什么是锁

###### 共享锁

###### 排它锁

###### 存储引擎

####### InnoDB

####### MyISAM

###### 逻辑结构修改

####### 锁表

####### 解决办法

######## 解决思路

######## pt-online-schema-change

##### 事务

###### 什么叫事务

###### 特性

####### 原子性

####### 一致性

####### 隔离性

####### 持久性

###### 隔离性级别

####### 未提交读

####### 以提交读

####### 可重复读

####### 可串行化

##### 逻辑设计

###### 范式设计

###### 反范式设计

##### 物理设计

###### 命名规范

###### 存储引擎选择

###### 数据类型选择

#### 4，查询以及索引

##### 慢查询

###### 慢查询配置

###### 慢查询分析

####### mysqldumpslow

####### pt-query-digest

##### 索引

###### 索引是什么

####### 索引的作用

####### BTree与B+Tree

###### 优缺点

###### 分类

####### 单值索引

####### 唯一索引

####### 复合索引

####### 全文索引

###### 语法

####### 创建

####### 删除

####### 查看

##### 执行计划

###### 什么是执行计划

###### 具体作用

####### 表的读取顺序

####### 数据读取操作的操作类型

####### 哪些索引可以使用

####### 哪些索引被实际使用

####### 表之间的引用

####### 每张表有多少行被优化器查询

###### 语法

###### 字段详解

####### id

####### select_type

####### table

####### type

####### possible_keys

####### key

####### key_len

####### ref

####### rows

####### Extra

##### Sql优化

###### 策略

####### 尽量全值匹配

####### 最佳左前缀法则

####### 不在索引列上做任何操作

####### 范围条件放最后

####### 覆盖索引尽量用

####### 不等于要甚用

####### Null/Not 有影响

####### Like查询要当心

####### 字符类型加引号

####### OR改UNION效率高

###### 总结

###### 批量导入

### Linux基础与进阶

#### Linux入门安装

#### Linux注意事项

#### Linux基础指令

#### Linux Jdk1.8环境安装及操作指令

#### Linux Tomcat安装与停启

### 设计模式实战
